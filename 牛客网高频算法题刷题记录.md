牛客网高频算法题刷题记录

链表

```c++
//1.翻转链表
class Solution {
public:
    ListNode* ReverseList(ListNode* pHead) {
        ListNode*pre=nullptr;
        ListNode *next=nullptr;
        while(pHead!=nullptr){
            next=pHead->next;
            pHead->next=pre;
            pre=pHead;
            pHead=next;
        }
        return pre;
    }
};
//2.合并两个排序链表
 ListNode* Merge(ListNode* pHead1, ListNode* pHead2) {
        if(!pHead1)return pHead2;
        else if(!pHead2)return pHead1;
        ListNode *pHead=nullptr;
        if(pHead1->val<pHead2->val){
            pHead=pHead1;
            pHead->next=Merge(pHead1->next, pHead2);
        }
        else{
            pHead=pHead2;
            pHead->next=Merge(pHead1, pHead2->next);
        }
        return pHead;
    }
//3.链表中环的入口节点
class Solution {
public:
    ListNode* EntryNodeOfLoop(ListNode* pHead) {
        ListNode*slow=pHead;
        ListNode*fast=pHead;
        while(fast!=nullptr&&fast->next!=nullptr){
            slow=slow->next;
            fast=fast->next->next;
            if(slow==fast){
                ListNode*index1=fast;
                ListNode*index2=pHead;
                while(index1!=index2){
                    index1=index1->next;
                    index2=index2->next;
                }
                return index2;
            }
        }
        return nullptr;
    }
};
//4.删除链表中的倒数第n个节点
ListNode* removeNthFromEnd(ListNode* head, int n) {
       //双指针法实现
        ListNode*dummy=new ListNode(-1);
        dummy->next=head;
        ListNode*fast=dummy;
        ListNode*slow=dummy;
        while(n--&&fast->next!=nullptr){
            fast=fast->next;
        }
        fast=fast->next;
        while(fast!=nullptr){
            slow=slow->next;
            fast=fast->next;
        }
        slow->next=slow->next->next;
        return dummy->next;
    }
//5.两个链表的第一个公共节点
ListNode* FindFirstCommonNode( ListNode* pHead1, ListNode* pHead2) {
        //法1：有手就行的哈希表法
        //法2：双指针法
        ListNode*p1=pHead1;
        ListNode*p2=pHead2;
        if(pHead1==nullptr||pHead2==nullptr)return nullptr;
        while(p1!=p2){
            p1=p1!=nullptr?p1->next:pHead2;
            p2=p2!=nullptr?p2->next:pHead1;
        }
        return p1;
    }
//6.判断是否为回文链表
 	bool isHuiwen(vector<int>&num){
        for(int i=0,j=num.size()-1;i<j;i++,j--){
            if(num[i]!=num[j])return false;
        }
        return true;
    }
    bool isPail(ListNode* head) {
        vector<int>vec;
        ListNode*cur=head;
        while(cur!=nullptr){
            vec.push_back(cur->val);
            cur=cur->next;
        }
        return isHuiwen(vec);
    }
//7.单链表的排序
ListNode* sortInList(ListNode* head) {
        // write code here
        //基本思路，用vector辅助
        //1.构建vector辅助数组
        vector<int>vec;
        ListNode* cur=head;
        while(cur!=nullptr){
            vec.push_back(cur->val);
            cur=cur->next;
        }
        //2.排序
        sort(vec.begin(),vec.end());
        //3.重建排序链表
        ListNode *dummy=new ListNode(0);
        ListNode *res=new ListNode(0);
        dummy->next=res;
        for(int i:vec){
            res->next=new ListNode(i);
            res=res->next;
        }
        res->next=nullptr;
        return dummy->next->next;
    }
```

2.二叉树

```c++
//1.求二叉树的最大深度
int maxDepth(TreeNode* root) {
        if(root==nullptr)return 0;
        int left=maxDepth(root->left);
        int right=maxDepth(root->right);
        return left>right?1+left:1+right;
    }
//2.二叉树的前序遍历
vector<int> preorderTraversal(TreeNode* root) {
        // write code here
        //迭代法实现
        vector<int>res;
        stack<TreeNode*>st;
        if(root!=nullptr)st.push(root);
        while(!st.empty()){
            TreeNode*node=st.top();
            st.pop();
            res.push_back(node->val);
            //前序遍历顺序根左右，入栈顺序根右左
            if(node->right)st.push(node->right);
            if(node->left)st.push(node->left);
        }
        return res;
    }
//3.二叉树的后序遍历
vector<int> postorderTraversal(TreeNode* root) {
        // write code here
        //迭代法实现
        vector<int>res;
        stack<TreeNode*>st;
        if(root!=nullptr){
            st.push(root);
        }
        while(!st.empty()){
            TreeNode *node=st.top();
            res.push_back(node->val);
            st.pop();
            if(node->left) st.push(node->left);
            if(node->right) st.push(node->right);
        }
        //反转顺序即可
        reverse(res.begin(), res.end());
        return res;
    }
//4.二叉树的层序遍历
vector<vector<int> > levelOrder(TreeNode* root) {
        vector<vector<int>>result;
        queue<TreeNode*>que;
        if(root!=nullptr)que.push(root);
        while(!que.empty()){
            int size=que.size();
            vector<int>vec;
            for(int i=0;i<size;i++){
                TreeNode*node=que.front();
                que.pop();
                vec.push_back(node->val);
                if(node->left)que.push(node->left);
                if(node->right)que.push(node->right);
            }
            result.push_back(vec);
        }
        return result;
    }
//5.之字形打印二叉树
 vector<vector<int> > Print(TreeNode* pRoot) {
        //在层序遍历的基础上改编
        vector<vector<int>>result;
        queue<TreeNode*>que;
        if(pRoot!=nullptr)que.push(pRoot);
        while(!que.empty()){
            int size=que.size();
            vector<int>vec;
            for(int i=0;i<size;i++){
                TreeNode*node=que.front();
                que.pop();
                vec.push_back(node->val);
                if(node->left)que.push(node->left);
                if(node->right)que.push(node->right);
            }
            //按照result数组的元素个数判断是否需要翻转
            if(result.size()%2==0){
                result.push_back(vec);
            }
            else{
                reverse(vec.begin(),vec.end());
                result.push_back(vec);
            }
        }
        return result;
    }
//6.二叉树的镜像
TreeNode* Mirror(TreeNode* pRoot) {
        // write code here
        //相当于翻转二叉树
        if(pRoot==nullptr)return nullptr;
        swap(pRoot->left,pRoot->right);
        Mirror(pRoot->left);
        Mirror(pRoot->right);
        return pRoot;
    }
//7.合并二叉树
TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) {
        // write code here
        TreeNode*root=new TreeNode(0);
        if(t1==nullptr)return t2;
        if(t2==nullptr)return t1;
        root->val=t1->val+t2->val;
        root->left=mergeTrees(t1->left, t2->left);
        root->right=mergeTrees(t1->right, t2->right);
        return root;
    }
//8.对称二叉树
    bool isSame(TreeNode* left,TreeNode* right){
        if(left==nullptr&&right==nullptr)return true;
        else if(left!=nullptr&&right==nullptr)return false;
        else if(left==nullptr&&right!=nullptr)return false;
        else if(left->val!=right->val)return false;
        return isSame(left->left, right->right)&&isSame(left->right, right->left);
       
    }
//判断一颗二叉树是否对称
    bool isSymmetrical(TreeNode* pRoot) {
        if(pRoot==nullptr)return true;
        return isSame(pRoot->left, pRoot->right);
    }
//9.判断是否是二叉搜索树
vector<int>vec;
    //中序遍历到数组中
    void traverse(TreeNode*root){
        if(root==nullptr)return;
        traverse(root->left);
        vec.push_back(root->val);
        traverse(root->right);
    }
    
    bool isValidBST(TreeNode* root) {
        // write code here
        vec.clear();
        traverse(root);
        for(int i=1;i<vec.size();i++){
            if(vec[i]<vec[i-1])return false;
        }
        return true;
    }
//10.判断是否是二叉平衡树
int getDepth(TreeNode *root){
        if(root==nullptr)return 0;
        int leftDepth=getDepth(root->left);
        if(leftDepth==-1)return -1;
        int rightDepth=getDepth(root->right);
        if(rightDepth==-1)return -1;
        return abs(leftDepth-rightDepth)>1?-1:1+max(leftDepth,rightDepth);
    }
    bool IsBalanced_Solution(TreeNode* pRoot) {
        return getDepth(pRoot)==-1?false:true;
    }
//11.和为某值的路径
 bool hasPathSum(TreeNode* root, int sum) {
        // write code here
       if(root==nullptr)return false;
       if(root->val==sum&&root->left==nullptr&&root->right==nullptr)return true;
        return hasPathSum(root->left, sum-root->val)||hasPathSum(root->right, sum-root->val);
    }

```

3.二分法

```c++
//1.用二分法在数组中查找指定值
 int search(vector<int>& nums, int target) {
        // write code here
        int left=0;
        int right=nums.size()-1;
        while(left<=right){
            int mid=left+(right-left)/2;
            if(nums[mid]>target){
                right=mid-1;
            }
            else if(nums[mid]<target){
                left=mid+1;
            }
            else{
                return mid;
            }
        }
        return -1;
    }
//2.二维数组中的查找
bool Find(int target, vector<vector<int> > array) {
       int m=array.size();
       int n=array[0].size();
       if(m==0||n==0)return false;
       int r=0,c=n-1;
        while(r<m&&c>=0){
            if(array[r][c]>target){
                c--;
            }
            else if(array[r][c]<target){
                r++;
            }
            else{
                return true;
            }
        }
        return false;
//3.寻找峰值
int findPeakElement(vector<int>& nums) {
        // write code here
        int left=0;
        int right=nums.size()-1;
        while(left<right){
            int mid=left+(right-left)/2;
            if(nums[mid]<nums[mid+1]){
                left=mid+1;
            }
            else{
                right=mid;
            }
        }
        return left;
//4.求旋转数组的最小值
int minNumberInRotateArray(vector<int> rotateArray) {
        //先二分在线性查找
        int l=0;
        int r=rotateArray.size()-1;
        while(l<r){
            int m=l+(r-l)/2;
            if(rotateArray[m]>rotateArray[r]){
                l=m+1;
            }
            else if(rotateArray[m]<rotateArray[r]){
                r=m;
            }
            else{
                int min=l;
                for(int k=l+1;k<r;k++){
                    if(rotateArray[k]<rotateArray[min])min=k;
                }
                return rotateArray[min];
            }
        }
        return rotateArray[l];
    }
//5.

```

4.字符串

```c++
//1.最长字符串前缀
 string longestCommonPrefix(vector<string>& strs) {
        // write code here
        string ans;
        //找到最小长度的字符串
        if(strs.empty())return ans;
        int n=INT_MAX;
        for(int i=0;i<strs.size();i++){
            n=min(n,(int)strs[i].size());
        }
        //按列查找
        for(int i=0;i<n;i++){
            for(int j=1;j<strs.size();j++){
                if(strs[j][i]!=strs[0][i])return ans;
            }
             ans+=strs[0][i];
        }
        return ans;
    }
```

5.动态规划

5.1 基础问题

```c++
//1.斐波那契数列
 int Fibonacci(int n) {
        if(n<=2)return 1;
        return Fibonacci(n-1)+Fibonacci(n-2);
    }
//2.爬楼梯（迭代法）
 //迭代法解决,跳台阶爬楼梯问题本质上是输出一个斐波那契数列问题
        int num1=1;
        int num2=2;
        if(number<=2)return number;
        int numN=0;
        while(number>2){
            numN=num1+num2;
            num1=num2;
            num2=numN;
            --number;
        }
        return numN;
        //递归法解决
        if(number<=2)return number;
        return jumpFloor(number-1)+jumpFloor(number-2);
//3.矩阵的最小路径和
int minPathSum(vector<vector<int> >& matrix) {
        // write code here
        //动态规划的经典题目
        int m=matrix.size();
        int n=matrix[0].size();
        vector<vector<int>>dp(m,vector<int>(n,0));
        dp[0][0]=matrix[0][0];
        //初始化
        for(int i=1;i<m;i++){
            dp[i][0]=dp[i-1][0]+matrix[i][0];
        }
        for(int j=1;j<n;j++){
            dp[0][j]=dp[0][j-1]+matrix[0][j];
        }
        for(int i=1;i<m;i++){
            for(int j=1;j<n;j++){
                dp[i][j]=min(dp[i-1][j],dp[i][j-1])+matrix[i][j];
            }
        }
        return dp[m-1][n-1];
    }
//4.不同路径的数目
 int uniquePaths(int m, int n) {
        // write code here
        //动态规划最基础最入门的题目
        vector<vector<int>>dp(m,vector<int>(n,0));
        //初始化数组
        for(int i=0;i<m;i++){
            dp[i][0]=1;
        }
        for(int j=0;j<n;j++){
            dp[0][j]=1;
        }
        for(int i=1;i<m;i++){
            for(int j=1;j<n;j++){
                dp[i][j]=dp[i-1][j]+dp[i][j-1];
            }
        }
        return dp[m-1][n-1];
    }
```

5.2 背包问题

5.3 子序列问题

1. 字符串
2. 动态规划